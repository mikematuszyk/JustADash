<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Creator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            gap: 20px;
            padding: 20px;
        }

        .toolbar {
            width: 250px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .canvas {
            background: white;
            border-radius: 10px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .sidepanel {
            width: 280px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        .widget {
            position: absolute;
            border: 2px solid transparent;
            cursor: move;
            transition: all 0.2s ease;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            word-wrap: break-word;
            text-overflow: ellipsis;
            user-select: none;
        }

        .widget:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .widget.selected {
            border-color: #00d4ff;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .widget.resizing {
            transition: none;
        }

        .widget.resizing:hover {
            transform: none;
        }

        .widget.dragging {
            transition: none;
            z-index: 9999 !important;
        }

        .section {
            margin-bottom: 25px;
        }

        .section h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 16px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-size: 14px;
            font-weight: 500;
        }

        .control-group input,
        .control-group select,
        .control-group button {
            width: 100%;
            padding: 10px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .control-group textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.2s ease;
            font-family: inherit;
            resize: vertical;
        }

        .control-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.2);
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.layer-btn {
            padding: 8px 16px;
            margin: 2px;
            font-size: 12px;
            min-width: auto;
            width: auto;
            display: inline-block;
        }

        .color-input {
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        .canvas-info {
            background: rgba(102, 126, 234, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
        }

        .widget-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            padding: 10px;
        }

        .widget-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #f8f9fa;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .widget-item:hover {
            background: #e9ecef;
        }

        .widget-item.selected {
            background: #667eea;
            color: white;
        }

        .layer-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .layer-info {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Toolbar -->
        <div class="toolbar">
            <div class="section">
                <h3>Canvas Presets</h3>
                <div class="control-group">
                    <label>Quick Presets</label>
                    <select id="canvasPresets" onchange="applyPreset()">
                        <option value="">Choose a preset...</option>
                        <option value="custom">Custom</option>
                        <option value="a4-portrait">A4 Portrait (210Ã—297)</option>
                        <option value="a4-landscape">A4 Landscape (297Ã—210)</option>
                        <option value="letter-portrait">US Letter Portrait (216Ã—279)</option>
                        <option value="letter-landscape">US Letter Landscape (279Ã—216)</option>
                        <option value="poster">Poster (420Ã—594)</option>
                        <option value="business-card">Business Card (89Ã—51)</option>
                        <option value="presentation">Presentation 16:9 (800Ã—450)</option>
                        <option value="social-post">Social Media Post (400Ã—400)</option>
                        <option value="banner">Web Banner (728Ã—90)</option>
                    </select>
                </div>
            </div>

            <div class="section">
                <h3>Canvas Controls</h3>
                <div class="control-group">
                    <label>Canvas Width</label>
                    <input type="number" id="canvasWidth" value="800" min="300" max="1500">
                </div>
                <div class="control-group">
                    <label>Canvas Height</label>
                    <input type="number" id="canvasHeight" value="600" min="200" max="1000">
                </div>
                <button class="btn" onclick="updateCanvasSize()">Update Canvas</button>
            </div>

            <div class="section">
                <h3>Export</h3>
                <div class="control-group">
                    <label>Export Format</label>
                    <select id="exportFormat">
                        <option value="html">HTML Document</option>
                        <option value="pdf">PDF Document</option>
                        <option value="png">PNG Image</option>
                    </select>
                </div>
                <button class="btn" onclick="exportCanvas()"
                    style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%);">
                    ðŸ“„ Export Canvas
                </button>
            </div>

            <div class="section">
                <h3>Add Widgets</h3>
                <div class="control-group">
                    <label>Widget Type</label>
                    <select id="widgetType">
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>
                <button class="btn" onclick="addWidget()">Add Widget</button>
            </div>

            <div class="section">
                <h3>Widget List</h3>
                <div class="widget-list" id="widgetList">
                    <div class="widget-item">No widgets yet</div>
                </div>
            </div>
        </div>

        <!-- Canvas -->
        <div class="canvas-container">
            <div class="canvas" id="canvas"></div>
        </div>

        <!-- Side Panel -->
        <div class="sidepanel" id="sidepanel">
            <div class="section">
                <h3>Canvas Properties</h3>
                <div class="canvas-info">
                    <strong>Current Size:</strong> <span id="currentSize">800 Ã— 600</span><br>
                    <strong>Widgets:</strong> <span id="widgetCount">0</span>
                </div>
                <div class="control-group">
                    <label>Background Color</label>
                    <input type="color" class="color-input" id="canvasColor" value="#ffffff"
                        onchange="updateCanvasColor()">
                </div>
            </div>
        </div>
    </div>

    <script>
        // Widget Registry System
        const WidgetRegistry = {
            widgets: new Map(),

            register(name, widgetClass, config = {}) {
                this.widgets.set(name, {
                    class: widgetClass,
                    label: config.label || name.charAt(0).toUpperCase() + name.slice(1),
                    description: config.description || '',
                    defaultSize: config.defaultSize || { width: 100, height: 80 }
                });
            },

            create(type, x, y, width, height) {
                const widgetInfo = this.widgets.get(type);
                if (!widgetInfo) {
                    throw new Error(`Widget type '${type}' not found`);
                }

                const size = widgetInfo.defaultSize;
                return new widgetInfo.class(
                    x, y,
                    width || size.width,
                    height || size.height
                );
            },

            getAll() {
                return Array.from(this.widgets.entries()).map(([key, value]) => ({
                    type: key,
                    ...value
                }));
            }
        };

        // Global variables
        let widgets = [];
        let selectedWidget = null;
        let nextZIndex = 1000;
        const canvas = document.getElementById('canvas');

        // Base Widget Class
        class BaseWidget {
            constructor(x = 50, y = 50, width = 100, height = 80, type = 'basic') {
                this.id = 'widget_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.element = null;
                this.selected = false;
                this.dragging = false;
                this.resizing = false;
                this.dragOffset = { x: 0, y: 0 };
                this.resizeData = null;
                this.zIndex = nextZIndex++;

                // Define parameter schema
                this.defineParameters();

                this.createDOMElement();
                this.attachEventListeners();
            }

            defineParameters() {
                this.parameters = {
                    x: { type: 'int', label: 'X Position', min: 0, value: this.x },
                    y: { type: 'int', label: 'Y Position', min: 0, value: this.y },
                    width: { type: 'int', label: 'Width', min: 20, max: 1000, value: this.width },
                    height: { type: 'int', label: 'Height', min: 20, max: 1000, value: this.height },
                    backgroundColor: { type: 'color', label: 'Background Color', value: '#667eea' }
                };
            }

            createDOMElement() {
                this.element = document.createElement('div');
                this.element.className = 'widget';
                this.element.id = this.id;
                this.element.style.position = 'absolute';
                this.element.style.zIndex = this.zIndex;
                this.updateStyles();
                this.updateContent();
            }

            updateStyles() {
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
                this.element.style.width = this.width + 'px';
                this.element.style.height = this.height + 'px';
            }

            updateContent() {
                this.element.textContent = this.type.charAt(0).toUpperCase() + this.type.slice(1);
            }

            attachEventListeners() {
                // Handle mousemove for cursor changes
                this.element.addEventListener('mousemove', (e) => {
                    if (this.dragging || this.resizing) return;

                    const rect = this.element.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const edgeThreshold = 8;

                    const isOnEdge = x <= edgeThreshold ||
                        y <= edgeThreshold ||
                        x >= rect.width - edgeThreshold ||
                        y >= rect.height - edgeThreshold;

                    if (isOnEdge) {
                        let direction = '';
                        if (y <= edgeThreshold) direction += 'n';
                        if (y >= rect.height - edgeThreshold) direction += 's';
                        if (x <= edgeThreshold) direction += 'w';
                        if (x >= rect.width - edgeThreshold) direction += 'e';

                        this.element.style.cursor = direction + '-resize';
                    } else {
                        this.element.style.cursor = 'move';
                    }
                });

                // Reset cursor when mouse leaves
                this.element.addEventListener('mouseleave', () => {
                    if (!this.dragging && !this.resizing) {
                        this.element.style.cursor = 'move';
                    }
                });

                // Handle mousedown on the widget
                this.element.addEventListener('mousedown', (e) => {
                    e.stopPropagation();

                    // Bring to front
                    this.bringToFront();

                    // Determine if click is on edge or inside
                    const rect = this.element.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const edgeThreshold = 8;

                    const isOnEdge = x <= edgeThreshold ||
                        y <= edgeThreshold ||
                        x >= rect.width - edgeThreshold ||
                        y >= rect.height - edgeThreshold;

                    if (isOnEdge) {
                        // Determine resize direction based on position
                        let direction = '';

                        if (y <= edgeThreshold) direction += 'n';
                        if (y >= rect.height - edgeThreshold) direction += 's';
                        if (x <= edgeThreshold) direction += 'w';
                        if (x >= rect.width - edgeThreshold) direction += 'e';

                        this.startEdgeResize(e, direction);
                    } else {
                        this.startDrag(e);
                    }
                });

                // Handle click for selection
                this.element.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.select();
                });
            }

            bringToFront() {
                this.zIndex = nextZIndex++;
                this.element.style.zIndex = this.zIndex;
            }

            sendToBack() {
                // Find the lowest z-index
                const minZ = Math.min(...widgets.map(w => w.zIndex));
                this.zIndex = minZ - 1;
                this.element.style.zIndex = this.zIndex;
            }

            moveUp() {
                // Find widgets with higher z-index
                const higherWidgets = widgets.filter(w => w.zIndex > this.zIndex);
                if (higherWidgets.length > 0) {
                    const nextHigher = Math.min(...higherWidgets.map(w => w.zIndex));
                    this.zIndex = nextHigher + 1;
                    this.element.style.zIndex = this.zIndex;
                }
            }

            moveDown() {
                // Find widgets with lower z-index
                const lowerWidgets = widgets.filter(w => w.zIndex < this.zIndex);
                if (lowerWidgets.length > 0) {
                    const nextLower = Math.max(...lowerWidgets.map(w => w.zIndex));
                    this.zIndex = nextLower - 1;
                    this.element.style.zIndex = this.zIndex;
                }
            }

            startDrag(e) {
                this.dragging = true;
                this.element.classList.add('dragging');

                // Get the mouse position relative to the canvas
                const canvasRect = canvas.getBoundingClientRect();
                const mouseCanvasX = e.clientX - canvasRect.left;
                const mouseCanvasY = e.clientY - canvasRect.top;

                // Calculate offset from mouse to widget's current position
                this.dragOffset.x = mouseCanvasX - this.x;
                this.dragOffset.y = mouseCanvasY - this.y;

                this.element.style.cursor = 'grabbing';

                document.addEventListener('mousemove', this.drag.bind(this));
                document.addEventListener('mouseup', this.stopDrag.bind(this));
                e.preventDefault();
            }

            startEdgeResize(e, direction) {
                this.resizing = true;
                this.element.classList.add('resizing');

                // Set appropriate cursor
                this.element.style.cursor = direction + '-resize';

                this.resizeData = {
                    direction,
                    startX: e.clientX,
                    startY: e.clientY,
                    startWidth: this.width,
                    startHeight: this.height,
                    startLeft: this.x,
                    startTop: this.y
                };

                document.addEventListener('mousemove', this.resize.bind(this));
                document.addEventListener('mouseup', this.stopResize.bind(this));
                e.preventDefault();
            }

            drag(e) {
                if (!this.dragging) return;

                const canvasRect = canvas.getBoundingClientRect();
                const mouseCanvasX = e.clientX - canvasRect.left;
                const mouseCanvasY = e.clientY - canvasRect.top;

                // Calculate new position: mouse position minus the original offset
                const newX = mouseCanvasX - this.dragOffset.x;
                const newY = mouseCanvasY - this.dragOffset.y;

                // Constrain to canvas bounds
                this.x = Math.max(0, Math.min(newX, canvas.offsetWidth - this.width));
                this.y = Math.max(0, Math.min(newY, canvas.offsetHeight - this.height));

                // Update parameter values
                this.parameters.x.value = this.x;
                this.parameters.y.value = this.y;

                this.updateStyles();

                // Update sidebar if this widget is selected
                if (this.selected) {
                    this.updateSidebarValues();
                }
            }

            resize(e) {
                if (!this.resizing || !this.resizeData) return;

                const deltaX = e.clientX - this.resizeData.startX;
                const deltaY = e.clientY - this.resizeData.startY;
                const direction = this.resizeData.direction;

                let newWidth = this.resizeData.startWidth;
                let newHeight = this.resizeData.startHeight;
                let newX = this.resizeData.startLeft;
                let newY = this.resizeData.startTop;

                // Handle horizontal resizing
                if (direction.includes('e')) {
                    newWidth = Math.max(20, this.resizeData.startWidth + deltaX);
                } else if (direction.includes('w')) {
                    newWidth = Math.max(20, this.resizeData.startWidth - deltaX);
                    newX = this.resizeData.startLeft + (this.resizeData.startWidth - newWidth);
                }

                // Handle vertical resizing
                if (direction.includes('s')) {
                    newHeight = Math.max(20, this.resizeData.startHeight + deltaY);
                } else if (direction.includes('n')) {
                    newHeight = Math.max(20, this.resizeData.startHeight - deltaY);
                    newY = this.resizeData.startTop + (this.resizeData.startHeight - newHeight);
                }

                // Constrain to canvas bounds
                newX = Math.max(0, Math.min(newX, canvas.offsetWidth - newWidth));
                newY = Math.max(0, Math.min(newY, canvas.offsetHeight - newHeight));

                // Update this widget's properties
                this.x = newX;
                this.y = newY;
                this.width = newWidth;
                this.height = newHeight;

                // Update parameter values
                this.parameters.x.value = this.x;
                this.parameters.y.value = this.y;
                this.parameters.width.value = this.width;
                this.parameters.height.value = this.height;

                // Update styles and content
                this.updateStyles();
                this.updateContent();

                // Update sidebar if this widget is selected
                if (this.selected) {
                    this.updateSidebarValues();
                }
            }

            stopDrag() {
                this.dragging = false;
                this.element.classList.remove('dragging');
                this.element.style.cursor = 'move';
                document.removeEventListener('mousemove', this.drag);
                document.removeEventListener('mouseup', this.stopDrag);
            }

            stopResize() {
                this.resizing = false;
                this.element.classList.remove('resizing');
                this.element.style.cursor = 'move';
                this.resizeData = null;
                document.removeEventListener('mousemove', this.resize);
                document.removeEventListener('mouseup', this.stopResize);
            }

            updateSidebarValues() {
                // Update sidebar input values without triggering change events
                const xInput = document.getElementById('param_x');
                const yInput = document.getElementById('param_y');
                const widthInput = document.getElementById('param_width');
                const heightInput = document.getElementById('param_height');

                if (xInput) xInput.value = this.x;
                if (yInput) yInput.value = this.y;
                if (widthInput) widthInput.value = this.width;
                if (heightInput) heightInput.value = this.height;
            }

            select() {
                // Deselect all widgets
                widgets.forEach(w => {
                    w.selected = false;
                    w.element.classList.remove('selected');
                });

                // Select this widget
                this.selected = true;
                this.element.classList.add('selected');
                selectedWidget = this;

                this.showSidePanel();
                updateWidgetList();
            }

            showSidePanel() {
                const sidepanel = document.getElementById('sidepanel');
                const controlsHTML = this.generateParameterControls();
                const layerControls = this.generateLayerControls();

                sidepanel.innerHTML = `
                    <div class="section">
                        <h3>${this.type.charAt(0).toUpperCase() + this.type.slice(1)} Widget</h3>
                        ${controlsHTML}
                        ${layerControls}
                        <button class="btn" onclick="deleteSelectedWidget()" style="background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);">Delete Widget</button>
                    </div>
                `;
            }

            generateLayerControls() {
                const currentLayer = widgets.length - widgets.indexOf(this);
                return `
                    <div class="control-group">
                        <label>Layer Controls</label>
                        <div class="layer-controls">
                            <button class="btn layer-btn" onclick="selectedWidget.bringToFront(); updateWidgetList();">Front</button>
                            <button class="btn layer-btn" onclick="selectedWidget.moveUp(); updateWidgetList();">Up</button>
                            <button class="btn layer-btn" onclick="selectedWidget.moveDown(); updateWidgetList();">Down</button>
                            <button class="btn layer-btn" onclick="selectedWidget.sendToBack(); updateWidgetList();">Back</button>
                        </div>
                        <div class="layer-info">Z-Index: ${this.zIndex}</div>
                    </div>
                `;
            }

            generateParameterControls() {
                let html = '';

                Object.entries(this.parameters).forEach(([key, param]) => {
                    html += `<div class="control-group">`;
                    html += `<label>${param.label}</label>`;

                    switch (param.type) {
                        case 'int':
                        case 'number':
                            html += `<input type="number" id="param_${key}" value="${param.value}" 
                                    ${param.min !== undefined ? `min="${param.min}"` : ''} 
                                    ${param.max !== undefined ? `max="${param.max}"` : ''} 
                                    ${param.step !== undefined ? `step="${param.step}"` : ''} 
                                    onchange="updateWidgetParameter('${key}', this.value)">`;
                            break;

                        case 'float':
                            html += `<input type="number" id="param_${key}" value="${param.value}" 
                                    step="0.1"
                                    ${param.min !== undefined ? `min="${param.min}"` : ''} 
                                    ${param.max !== undefined ? `max="${param.max}"` : ''} 
                                    onchange="updateWidgetParameter('${key}', this.value)">`;
                            break;

                        case 'color':
                            html += `<input type="color" class="color-input" id="param_${key}" value="${param.value}" 
                                    onchange="updateWidgetParameter('${key}', this.value)">`;
                            break;

                        case 'text':
                        case 'string':
                            html += `<input type="text" id="param_${key}" value="${param.value}" 
                                    ${param.maxlength ? `maxlength="${param.maxlength}"` : ''}
                                    onchange="updateWidgetParameter('${key}', this.value)">`;
                            break;

                        case 'textarea':
                            html += `<textarea id="param_${key}" rows="${param.rows || 3}" 
                                    ${param.maxlength ? `maxlength="${param.maxlength}"` : ''}
                                    onchange="updateWidgetParameter('${key}', this.value)">${param.value}</textarea>`;
                            break;

                        case 'select':
                            html += `<select id="param_${key}" onchange="updateWidgetParameter('${key}', this.value)">`;
                            param.options.forEach(option => {
                                const selected = option.value === param.value ? 'selected' : '';
                                html += `<option value="${option.value}" ${selected}>${option.label}</option>`;
                            });
                            html += `</select>`;
                            break;

                        case 'checkbox':
                            html += `<input type="checkbox" id="param_${key}" ${param.value ? 'checked' : ''} 
                                    onchange="updateWidgetParameter('${key}', this.checked)" style="width: auto; margin-right: 10px;">`;
                            break;

                        case 'range':
                            html += `<input type="range" id="param_${key}" value="${param.value}" 
                                    min="${param.min || 0}" max="${param.max || 100}" 
                                    step="${param.step || 1}"
                                    onchange="updateWidgetParameter('${key}', this.value)" oninput="this.nextElementSibling.textContent = this.value">
                                    <span>${param.value}</span>`;
                            break;

                        default:
                            html += `<input type="text" id="param_${key}" value="${param.value}" 
                                    onchange="updateWidgetParameter('${key}', this.value)">`;
                    }

                    html += `</div>`;
                });

                return html;
            }

            updateProperty(property, value) {
                // Convert value based on parameter type
                const param = this.parameters[property];
                if (param) {
                    switch (param.type) {
                        case 'int':
                            value = parseInt(value) || 0;
                            break;
                        case 'float':
                        case 'number':
                            value = parseFloat(value) || 0;
                            break;
                        case 'checkbox':
                            value = Boolean(value);
                            break;
                        // string, color, text, etc. stay as-is
                    }

                    // Update parameter value
                    param.value = value;
                }

                // Update widget property
                this[property] = value;

                // Apply visual updates
                this.applyPropertyChange(property, value);
            }

            applyPropertyChange(property, value) {
                // Handle standard positioning and sizing
                if (['x', 'y', 'width', 'height'].includes(property)) {
                    this.updateStyles();
                }

                // Handle background color
                if (property === 'backgroundColor') {
                    this.element.style.background = value;
                    this.element.style.backgroundImage = 'none';
                }

                // Content updates for size changes
                if (property === 'width' || property === 'height') {
                    this.updateContent();
                }
            }

            // Render method for export - returns clean HTML
            render() {
                const div = document.createElement('div');
                div.style.position = 'absolute';
                div.style.left = this.x + 'px';
                div.style.top = this.y + 'px';
                div.style.width = this.width + 'px';
                div.style.height = this.height + 'px';
                div.style.background = this.parameters.backgroundColor.value;
                div.style.borderRadius = '8px';
                div.style.display = 'flex';
                div.style.alignItems = 'center';
                div.style.justifyContent = 'center';
                div.style.fontWeight = 'bold';
                div.style.color = '#333';
                div.style.fontSize = '14px';
                div.style.fontFamily = 'Arial, sans-serif';
                div.style.overflow = 'hidden';
                div.style.wordWrap = 'break-word';
                div.style.textOverflow = 'ellipsis';
                div.style.userSelect = 'none';
                div.textContent = this.type.charAt(0).toUpperCase() + this.type.slice(1);
                return div;
            }

            destroy() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
            }
        }

        // Specialized Widget Classes
        class TextWidget extends BaseWidget {
            constructor(x, y, width, height) {
                super(x, y, width, height, 'text');
                this.text = 'Sample Text';
                this.fontSize = 16;
                this.textColor = '#333333';
                this.backgroundColor = '#f0f0f0';
                this.fontWeight = 'normal';
                this.textAlign = 'center';
                this.element.style.background = this.backgroundColor;
                this.element.style.color = this.textColor;
                this.element.style.padding = '8px';
                this.element.style.boxSizing = 'border-box';
                this.element.style.whiteSpace = 'normal';
                this.element.style.wordBreak = 'break-word';
                this.element.style.lineHeight = '1.2';
                this.updateContent();
            }

            defineParameters() {
                super.defineParameters();
                // Override background color default
                this.parameters.backgroundColor.value = '#f0f0f0';

                // Add text-specific parameters
                this.parameters.text = {
                    type: 'textarea',
                    label: 'Text Content',
                    value: this.text,
                    rows: 3,
                    maxlength: 500
                };
                this.parameters.fontSize = {
                    type: 'range',
                    label: 'Font Size',
                    value: this.fontSize,
                    min: 8,
                    max: 72,
                    step: 1
                };
                this.parameters.textColor = {
                    type: 'color',
                    label: 'Text Color',
                    value: this.textColor
                };
                this.parameters.fontWeight = {
                    type: 'select',
                    label: 'Font Weight',
                    value: this.fontWeight,
                    options: [
                        { value: 'normal', label: 'Normal' },
                        { value: 'bold', label: 'Bold' },
                        { value: '300', label: 'Light' },
                        { value: '600', label: 'Semi-Bold' }
                    ]
                };
                this.parameters.textAlign = {
                    type: 'select',
                    label: 'Text Alignment',
                    value: this.textAlign,
                    options: [
                        { value: 'left', label: 'Left' },
                        { value: 'center', label: 'Center' },
                        { value: 'right', label: 'Right' }
                    ]
                };
            }

            updateContent() {
                this.element.textContent = this.text;
                this.element.style.fontSize = this.fontSize + 'px';
                this.element.style.fontWeight = this.fontWeight;
                this.element.style.textAlign = this.textAlign;
            }

            applyPropertyChange(property, value) {
                super.applyPropertyChange(property, value);

                if (property === 'text') {
                    this.element.textContent = value;
                }
                if (property === 'fontSize') {
                    this.element.style.fontSize = value + 'px';
                }
                if (property === 'fontWeight') {
                    this.element.style.fontWeight = value;
                }
                if (property === 'textAlign') {
                    this.element.style.textAlign = value;
                }
                if (property === 'textColor') {
                    this.element.style.color = value;
                }
                if (property === 'backgroundColor') {
                    this.element.style.background = value;
                    this.element.style.backgroundImage = 'none';
                }
            }

            // Render method for export - returns clean HTML
            render() {
                const div = document.createElement('div');
                div.style.position = 'absolute';
                div.style.left = this.x + 'px';
                div.style.top = this.y + 'px';
                div.style.width = this.width + 'px';
                div.style.height = this.height + 'px';
                div.style.background = this.backgroundColor;
                div.style.color = this.textColor;
                div.style.fontSize = this.fontSize + 'px';
                div.style.fontWeight = this.fontWeight;
                div.style.textAlign = this.textAlign;
                div.style.fontFamily = 'Arial, sans-serif';
                div.style.padding = '8px';
                div.style.boxSizing = 'border-box';
                div.style.whiteSpace = 'normal';
                div.style.wordBreak = 'break-word';
                div.style.lineHeight = '1.2';
                div.style.display = 'flex';
                div.style.alignItems = 'center';
                div.style.justifyContent = this.textAlign === 'left' ? 'flex-start' :
                    this.textAlign === 'right' ? 'flex-end' : 'center';
                div.style.overflow = 'hidden';
                div.textContent = this.text;
                return div;
            }
        }

        class ImageWidget extends BaseWidget {
            constructor(x, y, width, height) {
                super(x, y, width, height, 'image');
                this.imageSrc = '';
                this.borderRadius = 8;
                this.opacity = 1.0;
                this.objectFit = 'cover';
                // Set initial background
                this.element.style.background = '#84fab0';
                this.element.style.backgroundImage = 'none';
                this.element.innerHTML = '<div style="text-align: center;">ðŸ“·<br>Image</div>';
            }

            defineParameters() {
                super.defineParameters();
                // Override background color default
                this.parameters.backgroundColor.value = '#84fab0';

                // Add image-specific parameters
                this.parameters.imageSrc = {
                    type: 'text',
                    label: 'Image URL',
                    value: this.imageSrc
                };
                this.parameters.borderRadius = {
                    type: 'range',
                    label: 'Border Radius',
                    value: this.borderRadius,
                    min: 0,
                    max: 50,
                    step: 1
                };
                this.parameters.opacity = {
                    type: 'range',
                    label: 'Opacity',
                    value: this.opacity,
                    min: 0.1,
                    max: 1.0,
                    step: 0.1
                };
                this.parameters.objectFit = {
                    type: 'select',
                    label: 'Image Fit',
                    value: this.objectFit,
                    options: [
                        { value: 'cover', label: 'Cover' },
                        { value: 'contain', label: 'Contain' },
                        { value: 'fill', label: 'Fill' },
                        { value: 'scale-down', label: 'Scale Down' }
                    ]
                };
            }

            applyPropertyChange(property, value) {
                super.applyPropertyChange(property, value);

                if (property === 'imageSrc') {
                    if (value) {
                        this.element.style.backgroundImage = `url(${value})`;
                        this.element.style.backgroundSize = this.objectFit;
                        this.element.style.backgroundPosition = 'center';
                        this.element.innerHTML = '';
                    } else {
                        this.element.style.backgroundImage = '';
                        this.element.style.background = this.parameters.backgroundColor.value;
                        this.element.innerHTML = '<div style="text-align: center;">ðŸ“·<br>Image</div>';
                    }
                }
                if (property === 'borderRadius') {
                    this.element.style.borderRadius = value + 'px';
                }
                if (property === 'opacity') {
                    this.element.style.opacity = value;
                }
                if (property === 'objectFit') {
                    this.element.style.backgroundSize = value;
                }
                if (property === 'backgroundColor') {
                    if (!this.imageSrc) {
                        this.element.style.background = value;
                        this.element.style.backgroundImage = 'none';
                    }
                }
            }

            // Render method for export - returns clean HTML
            render() {
                const div = document.createElement('div');
                div.style.position = 'absolute';
                div.style.left = this.x + 'px';
                div.style.top = this.y + 'px';
                div.style.width = this.width + 'px';
                div.style.height = this.height + 'px';
                div.style.borderRadius = this.borderRadius + 'px';
                div.style.opacity = this.opacity;
                div.style.overflow = 'hidden';

                if (this.imageSrc) {
                    div.style.backgroundImage = `url(${this.imageSrc})`;
                    div.style.backgroundSize = this.objectFit;
                    div.style.backgroundPosition = 'center';
                    div.style.backgroundRepeat = 'no-repeat';
                } else {
                    div.style.background = this.backgroundColor;
                    div.style.display = 'flex';
                    div.style.alignItems = 'center';
                    div.style.justifyContent = 'center';
                    div.style.fontFamily = 'Arial, sans-serif';
                    div.style.fontSize = '14px';
                    div.style.color = '#666';
                    div.innerHTML = 'ðŸ“·<br>Image';
                }

                return div;
            }
        }

        // Register all available widgets
        WidgetRegistry.register('basic', BaseWidget, {
            label: 'Basic Rectangle',
            description: 'Simple colored rectangle',
            defaultSize: { width: 100, height: 80 }
        });

        WidgetRegistry.register('text', TextWidget, {
            label: 'Text Widget',
            description: 'Text container with formatting options',
            defaultSize: { width: 150, height: 60 }
        });

        WidgetRegistry.register('image', ImageWidget, {
            label: 'Image Widget',
            description: 'Image placeholder with URL support',
            defaultSize: { width: 120, height: 100 }
        });

        // Canvas presets with correct proportions
        const CANVAS_PRESETS = {
            'a4-portrait': { width: 595, height: 842, name: 'A4 Portrait' },
            'a4-landscape': { width: 842, height: 595, name: 'A4 Landscape' },
            'letter-portrait': { width: 612, height: 792, name: 'US Letter Portrait' },
            'letter-landscape': { width: 792, height: 612, name: 'US Letter Landscape' },
            'poster': { width: 600, height: 800, name: 'Poster' },
            'business-card': { width: 252, height: 144, name: 'Business Card' },
            'presentation': { width: 800, height: 450, name: 'Presentation 16:9' },
            'social-post': { width: 400, height: 400, name: 'Social Media Post' },
            'banner': { width: 728, height: 90, name: 'Web Banner' }
        };

        // Initialize canvas
        function initCanvas() {
            updateCanvasSize();
            populateWidgetSelector();
            canvas.addEventListener('click', (e) => {
                if (e.target === canvas) {
                    deselectAllWidgets();
                }
            });
        }

        function applyPreset() {
            const presetSelect = document.getElementById('canvasPresets');
            const preset = CANVAS_PRESETS[presetSelect.value];

            if (preset) {
                document.getElementById('canvasWidth').value = preset.width;
                document.getElementById('canvasHeight').value = preset.height;
                updateCanvasSize();
            }
        }

        function exportCanvas() {
            const format = document.getElementById('exportFormat').value;

            switch (format) {
                case 'html':
                    exportAsHTML();
                    break;
                case 'pdf':
                    exportAsPDF();
                    break;
                case 'png':
                    exportAsPNG();
                    break;
            }
        }

        function exportAsHTML() {
            // Create clean HTML version
            const exportContainer = document.createElement('div');
            exportContainer.style.position = 'relative';
            exportContainer.style.width = canvas.offsetWidth + 'px';
            exportContainer.style.height = canvas.offsetHeight + 'px';
            exportContainer.style.backgroundColor = canvas.style.backgroundColor || '#ffffff';
            exportContainer.style.fontFamily = 'Arial, sans-serif';
            exportContainer.style.overflow = 'hidden';

            // Sort widgets by z-index for proper layering
            const sortedWidgets = [...widgets].sort((a, b) => a.zIndex - b.zIndex);

            // Add rendered widgets
            sortedWidgets.forEach(widget => {
                const renderedWidget = widget.render();
                exportContainer.appendChild(renderedWidget);
            });

            // Create complete HTML document
            const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exported Canvas</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f5f5f5;
        }
        .canvas-export {
            margin: 0 auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div class="canvas-export">
        ${exportContainer.outerHTML}
    </div>
</body>
</html>`;

            // Download HTML file
            downloadFile(htmlContent, 'canvas-export.html', 'text/html');
        }

        function exportAsPDF() {
            // For PDF export, we'll create HTML and suggest using browser's print to PDF
            exportAsHTML();

            setTimeout(() => {
                alert('HTML file downloaded! To convert to PDF:\n\n1. Open the HTML file in your browser\n2. Press Ctrl+P (or Cmd+P on Mac)\n3. Choose "Save as PDF" as destination\n4. Adjust settings as needed and save\n\nThis ensures the best quality and compatibility.');
            }, 500);
        }

        function exportAsPNG() {
            // Create a temporary canvas for image export
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');

            // Set canvas size
            tempCanvas.width = canvas.offsetWidth;
            tempCanvas.height = canvas.offsetHeight;

            // Fill background
            ctx.fillStyle = canvas.style.backgroundColor || '#ffffff';
            ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // Note: This is a simplified PNG export. Full implementation would require
            // html2canvas library or similar for complex widgets
            alert('PNG export is simplified in this demo. For full PNG export functionality, you would need to integrate a library like html2canvas or use server-side rendering.');

            // Simple text-based export for demonstration
            const sortedWidgets = [...widgets].sort((a, b) => a.zIndex - b.zIndex);

            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            sortedWidgets.forEach(widget => {
                // Draw basic representation
                ctx.fillStyle = widget.parameters.backgroundColor.value;
                ctx.fillRect(widget.x, widget.y, widget.width, widget.height);

                if (widget.type === 'text') {
                    ctx.fillStyle = widget.textColor;
                    ctx.font = `${widget.fontSize}px Arial`;
                    ctx.fillText(widget.text, widget.x + widget.width / 2, widget.y + widget.height / 2);
                } else {
                    ctx.fillStyle = '#333';
                    ctx.fillText(widget.type, widget.x + widget.width / 2, widget.y + widget.height / 2);
                }
            });

            // Download PNG
            tempCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'canvas-export.png';
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function populateWidgetSelector() {
            const selector = document.getElementById('widgetType');
            selector.innerHTML = '';

            WidgetRegistry.getAll().forEach(widget => {
                const option = document.createElement('option');
                option.value = widget.type;
                option.textContent = widget.label;
                option.title = widget.description;
                selector.appendChild(option);
            });
        }

        function updateCanvasSize() {
            const width = document.getElementById('canvasWidth').value;
            const height = document.getElementById('canvasHeight').value;

            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            document.getElementById('currentSize').textContent = `${width} Ã— ${height}`;
        }

        function updateCanvasColor() {
            const color = document.getElementById('canvasColor').value;
            canvas.style.backgroundColor = color;
        }

        function addWidget() {
            const type = document.getElementById('widgetType').value;
            const x = Math.random() * (canvas.offsetWidth - 150);
            const y = Math.random() * (canvas.offsetHeight - 80);

            try {
                const widget = WidgetRegistry.create(type, x, y);

                // Apply initial styling based on type
                if (type === 'basic') {
                    widget.element.style.background = widget.parameters.backgroundColor.value;
                    widget.element.style.backgroundImage = 'none';
                }

                widgets.push(widget);
                canvas.appendChild(widget.element);

                updateWidgetCount();
                updateWidgetList();
            } catch (error) {
                console.error('Failed to create widget:', error);
            }
        }

        function updateWidgetParameter(property, value) {
            if (selectedWidget) {
                selectedWidget.updateProperty(property, value);
            }
        }

        function deleteSelectedWidget() {
            if (selectedWidget) {
                const index = widgets.indexOf(selectedWidget);
                if (index > -1) {
                    selectedWidget.destroy();
                    widgets.splice(index, 1);
                    selectedWidget = null;
                    showCanvasProperties();
                    updateWidgetCount();
                    updateWidgetList();
                }
            }
        }

        function deselectAllWidgets() {
            widgets.forEach(w => {
                w.selected = false;
                w.element.classList.remove('selected');
            });
            selectedWidget = null;
            showCanvasProperties();
            updateWidgetList();
        }

        function showCanvasProperties() {
            const sidepanel = document.getElementById('sidepanel');
            sidepanel.innerHTML = `
                <div class="section">
                    <h3>Canvas Properties</h3>
                    <div class="canvas-info">
                        <strong>Current Size:</strong> <span id="currentSize">${canvas.offsetWidth} Ã— ${canvas.offsetHeight}</span><br>
                        <strong>Widgets:</strong> <span id="widgetCount">${widgets.length}</span>
                    </div>
                    <div class="control-group">
                        <label>Background Color</label>
                        <input type="color" class="color-input" id="canvasColor" value="#ffffff" onchange="updateCanvasColor()">
                    </div>
                </div>
            `;
        }

        function updateWidgetCount() {
            const countElements = document.querySelectorAll('#widgetCount');
            countElements.forEach(el => el.textContent = widgets.length);
        }

        function updateWidgetList() {
            const listContainer = document.getElementById('widgetList');

            if (widgets.length === 0) {
                listContainer.innerHTML = '<div class="widget-item">No widgets yet</div>';
                return;
            }

            // Sort widgets by z-index (highest first)
            const sortedWidgets = [...widgets].sort((a, b) => b.zIndex - a.zIndex);

            listContainer.innerHTML = sortedWidgets.map((widget, index) =>
                `<div class="widget-item ${widget.selected ? 'selected' : ''}" onclick="selectWidgetFromList('${widget.id}')">
                    <span>${widget.type.charAt(0).toUpperCase() + widget.type.slice(1)} #${widgets.indexOf(widget) + 1}</span>
                    <small style="opacity: 0.7;">Layer ${sortedWidgets.length - index}</small>
                </div>`
            ).join('');
        }

        function selectWidgetFromList(widgetId) {
            const widget = widgets.find(w => w.id === widgetId);
            if (widget) {
                widget.select();
            }
        }

        // Initialize the application
        initCanvas();
        showCanvasProperties();
    </script>
</body>

</html>